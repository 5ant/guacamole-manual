<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook V5.0//EN"
    "http://docbook.org/xml/5.0/dtd/docbook.dtd">

<chapter id="custom protocols" 
    xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
    xmlns:xi="http://www.w3.org/2001/XInclude">

    <title>Adding new protocols</title>

    <para>
        In this tutorial, we implement a simple "client" which renders a
        bouncing ball using the Guacamole protocol. After completing the
        tutorial and installing the result, you will be able to add a
        connection to your Guacamole configuration using the "ball" protocol,
        and any users using that connection will see a bouncing ball.
    </para>

    <para>
        This example client plugin doesn't actually act as a client, but this
        isn't important. The Guacamole client is really just a remote display,
        and this client plugin functions as a simple example application which
        renders to this display, just as the VNC or RDP support plugins
        function as VNC or RDP clients which render to the remote display.
    </para>

    <para>
        Each step of this tutorial is intended to excercise a new concept,
        while also progressing towards the goal of a nifty bouncing ball. At
        the end of each step, you will have a buildable and working client
        plugin.
    </para>    

    <section id="libguac-client-ball-skeleton">

        <title>Minimal skeleton client</title>

        <para>
            Very little needs too be done to implement the most basic client
            plugin possible:
        </para>

        <xi:include href="tut/ball/01/ball_client.c.xml"/>

        <para>
            Notice the structure of this file. There is exactly one function,
            guac_client_init, which is the entry point for all Guacamole client
            plugins. Just as a typical C program has a main function which is
            executed when the program is run, a Guacamole client plugin has
            guac_client_init which is called when guacd loads the plugin when a
            new connection is made and your protocol is selected.
        </para>

        <para>
            guac_client_init receives a single guac_client and the same argc
            and argv arguments that are typical of a C entry point.
        </para>

        <para>
            The guac_client given will live until the connection with the
            remote display closes. Your guac_client_function is expected to
            parse any arguments in argv and initialized the given guac_client,
            returning a success code (zero) if the client was initialized
            successfully.
        </para>

        <para>
            Place this code in a file called ball_client.c in a subdirectory
            called src. The build files provided by this tutorial assume this
            is the location of all source code.
        </para>

        <para>
            This tutorial, as well as all other C-based Guacamole projects,
            uses the GNU Automake build system due to its ubiquity and ease of
            use. The minimal build files required for a libguac-based project
            that uses GNU Automake are fairly simple:
        </para>

        <xi:include href="tut/ball/01/configure.in.xml"/>

        <xi:include href="tut/ball/01/Makefile.am.xml"/>

        <para>
            The GNU Automake files will remain largely unchanged throughout the
            rest of the tutorial.
        </para>

        <para>
            Once you have created all of the above files, you will have a
            functioning client plugin. It doesn't do anything yet, but it does
            work, and guacd will load it when requested, and unload it when the
            connection terminates.
        </para>

    </section>

    <section id="libguac-client-ball-display-init">

        <title>Initializing the remote display</title>

        <para>
            Now that we have a basic functioning skeleton, we need to actually
            do something with the remote display. A good first step would be
            initializing the display - giving the connection a name, setting
            the remote display size, and providing a basic background.
        </para>

        <para>
            In this case, we name our connection "Bouncing Ball", set the
            display to a nice default of 1024x768, and fil the background with
            a simple gray.
        </para>

        <xi:include href="tut/ball/02/ball_client.c.xml"/>

        <para>
            Note how communication is done with the remote display. The
            guac_client given to guac_client_init has a member, socket, which
            is used for bidirectional communication. Guacamole protocol
            functions, all starting with "guac_protocol_send_", provide a
            slightly high-level mechanism for sending specific Guacamole
            protocol instructions to the remote display over the client's
            socket.
        </para>

        <para>
            Here, we set the name of the connection using a "name" instruction
            (using guac_protocol_send_name), we resize the display using a
            "size" instruction (using guac_protocol_send_size), and we then
            draw to the display using drawing instructions (rect and cfill).
        </para>

    </section>

    <section id="libguac-client-ball-layer">

        <title>Adding the ball</title>

        <para>
            This tutorial is about making a bouncing ball "client", so
            naturally we need a ball to bounce.
        </para>

        <para>
            While we could repeatedly draw and erase a ball on the remote
            display, a more efficient technique would be to leverage
            Guacamole's layers.
        </para>

        <para>
            The remote display has a single root layer, GUAC_DEFAULT_LAYER, but
            there can be infinitely many other child layers, which can have
            themselves have child layers, and so on. Each layer can be
            dynamically repositioned within and relative to another layer.
            Because the compositing of these layers is handled by the remote
            display, and is likely hardware-accelerated, this is a much better
            way to repeatedly reposition something we expect to move a lot.
        </para>

        <xi:include href="tut/ball/03/ball_client.c.xml"/>

        <para>
            Beyond layers, Guacamole has the concept of buffers, which are
            identical in use to layers except they are invisible. Buffers are
            used to store image data for the sake of caching or drawing
            operations. We will use them later when we try to make this
            tutorial prettier.
        </para>

        <para>
            If you build and install the ball client as is now, you will see a
            large gray rectangle (the root layer) with a small blue square in
            the upper left corner (the ball layer).
        </para>

    </section>

    <section id="libguac-client-ball-bounce">

        <title>Making the ball bounce</title>

        <para>
            To make the ball bounce, we need to track the ball's state,
            including current position and velocity. This state information
            needs to be stored with the client such that it becomes available
            to all client handlers.
        </para>

        <para>
            The best way to do this is to create a data structure that contains
            all the information we need, and store it in the "data" member of
            the guac_client. We create a header file to declare the structure:
        </para>

        <xi:include href="tut/ball/04/ball_client.h.xml"/>

        <para>
            And we update guac_client_init to initialize the structure, store
            it in the client, and register our new event handler.
        </para>

        <para>
            guacd will call the handle_messages handler of the guac_client
            repeatedly, if defined. It will stop calling handle_messages
            temporarily if the remote display appears to be lagging behind due
            to a slow network or slow browser or computer, so there is no
            guarantee that handle_messages will be called as frequently as we
            would like, but for now, we assume there will be essentially no
            delay between calls, and we include our own delay of 30ms between
            frames.
        </para>

        <xi:include href="tut/ball/04/ball_client.c.xml"/>

        <para>
            Because we now have header files, we need to update Makefile.am to
            include our header and the directory it's in:
        </para>

        <xi:include href="tut/ball/04/Makefile.am.xml"/>

        <para>
            Once built and installed, our ball client now has a bouncing ball,
            albeit a very square and plain one.
        </para>

    </section>

    <section id="libguac-client-ball-pretty">

        <title>A prettier ball</title>

        <para>
            Now that we have our ball bouncing, we might as well try to make it
            actually look like a ball, and try applying some of the fancier
            graphics features that Guacamole offers.
        </para>

        <para>
            Guacamole provides instructions common to most 2D drawing APIs,
            including HTML5's canvas and Cairo. This means you can draw arcs,
            curves, apply fill and stroke, and even use the contents of another
            layer or buffer as the pattern for a fill or stroke.
        </para>

        <para>
            We will try creating a simple gray checkerboard pattern in a buffer
            and use that for the background instead of the previous gray
            rectangle.
        </para>

        <para>
            We will also modify the ball, removing the rectangle, and replacing
            it with an arc, in this case a circle, complete with stroke
            (border) and translucent-blue fill.
        </para>

        <xi:include href="tut/ball/05/ball_client.c.xml"/>

        <para>
            Again, because we put the ball in its own layer, we don't have to
            worry about compositing it ourselves. The remote display will
            handle this, and will likely do so with hardware acceleration.
        </para>

        <para>
            Build and install the ball client after this step, and you will
            have a rather nice-looking bouncing ball.
        </para>

    </section>

    <section id="libguac-client-ball-time">

        <title>Handling the passage of time</title>

        <para>
            Because the handle_messages handler will only be called as guacd
            deems appropriate, we cannot rely on instantaneous return of
            control. The server may experience load, causing guacd to lose
            priority and delay handling of messages, or the remote display may
            lag due to network or software issues, forcing guacd to temporarily
            pause updates.
        </para>

        <para>
            We must modify our ball state to include the time the last update
            took place. We can then modify the message handler to check the
            last update time, and update the ball's position based on its
            current velocity and the elapsed time.
        </para>

        <xi:include href="tut/ball/06/ball_client.h.xml"/>
        <xi:include href="tut/ball/06/ball_client.c.xml"/>

        <para>
            At this point, we now have a robust Guacamole client plugin. It
            properly handles the lack of time guarantees for message handler
            calls, meanwhile providing the user with a seamlessly bouncing
            ball.
        </para>

    </section>

</chapter>
